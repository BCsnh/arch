#!/usr/bin/env python

import argparse
import yaml
import sys
import logging
import importlib
from core.arch_manager import ArchManager
from core.arch_client import ArchClient
import os
import signal
from datetime import datetime
import pandas as pd
import core.replay_helper as replay_helper  # Adjusted import for core/replay_helper.py

def load_config(file_path):
    with open(file_path, 'r') as f:
        return yaml.safe_load(f)

def setup_logging(config, mode, is_server=False, client_dir=None, config_name=None, run_timestamp=None, mode_str=None):
    current_date = datetime.now().strftime('%Y%m%d')

    if is_server:
        # Server logs: server_live_<configname>_<date>.log
        log_dir = config.get('log_dir', './logs/server')
        os.makedirs(log_dir, exist_ok=True)
        log_file = f"{log_dir}/server_live_{config_name}_{current_date}.log"
    else:
        # Client logs
        client_name = config['client_name']  # Use client_name from config
        log_dir = os.path.join(client_dir, config.get('log_dir', 'logs'))  # Relative to client folder
        os.makedirs(log_dir, exist_ok=True)
        if mode == 'live':
            # client_<myclientname>_live_<configname>_<date>.log
            log_file = f"{log_dir}/client_{client_name}_live_{config_name}_{current_date}.log"
        else:  # replay
            start_date = pd.to_datetime(config['historical_range']['start']).strftime('%Y%m%d')
            end_date = pd.to_datetime(config['historical_range']['end']).strftime('%Y%m%d')
            log_file = f"{log_dir}/client_{client_name}_replay_{config_name}_{start_date}_{end_date}_{mode_str}_{run_timestamp}.log"

    logging.basicConfig(
        level=logging.INFO,  # Change to logging.DEBUG for more details
        format='%(asctime)s - %(levelname)s - %(processName)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )
    return log_dir  # Return log_dir for use in subjob logs

def write_pid(pid_file):
    os.makedirs(os.path.dirname(pid_file), exist_ok=True)  # Create dir if needed (e.g., for client pids)
    with open(pid_file, 'w') as f:
        f.write(str(os.getpid()))

def stop_process(pid_file):
    if not os.path.exists(pid_file):
        print(f"No process found for {pid_file}")
        sys.exit(1)
    with open(pid_file, 'r') as f:
        pid = int(f.read().strip())
    try:
        os.kill(pid, signal.SIGTERM)
        print(f"Sent termination signal to PID {pid}")
        os.remove(pid_file)  # Clean up PID file
    except ProcessLookupError:
        print(f"Process {pid} not found")
        os.remove(pid_file)
    except Exception as e:
        print(f"Error stopping process: {e}")

def main():
    parser = argparse.ArgumentParser(description="Arch Framework CLI")
    subparsers = parser.add_subparsers(dest='command', required=True)

    # start_server subcommand
    server_parser = subparsers.add_parser('start_server')
    server_parser.add_argument('mode', choices=['live'], help="Mode (only live for server)")
    server_parser.add_argument('config_file', help="Server config YAML file")

    # start_client subcommand
    client_parser = subparsers.add_parser('start_client')
    client_parser.add_argument('mode', choices=['live', 'replay'], help="Mode (live or replay)")
    client_parser.add_argument('client_script', help="Client script file (e.g., clients/client1.py)")
    client_parser.add_argument('config_file', help="Client config YAML file")
    client_parser.add_argument('--parallel', action='store_true', help="Run replay in parallel mode (default: sequential)")
    client_parser.add_argument('--num_processes', '-n', type=int, default=4, help="Number of parallel processes (default: 4, max: 20)")
    client_parser.add_argument('--timeout', type=int, default=30, help="Timeout per subjob in minutes (default: 30)")

    # stop_server subcommand
    stop_server_parser = subparsers.add_parser('stop_server')
    stop_server_parser.add_argument('region', help="Region of the server to stop (e.g., amer)")

    # stop_client subcommand (takes client_script and config_file)
    stop_client_parser = subparsers.add_parser('stop_client')
    stop_client_parser.add_argument('client_script', help="Client script file to locate PID folder")
    stop_client_parser.add_argument('config_file', help="Client config YAML file to load client_name")

    args = parser.parse_args()

    if args.command == 'start_server':
        if args.mode != 'live':
            sys.exit("Server only supports live mode.")
        config = load_config(args.config_file)
        if 'region' not in config:
            sys.exit("Config must include 'region' (e.g., amer, apac).")
        config['mode'] = 'live'
        config_name = os.path.splitext(os.path.basename(args.config_file))[0]  # e.g., 'server_amer'
        setup_logging(config, config['mode'], is_server=True, config_name=config_name)  # Server-specific logging
        pid_file = f"pids/arch_server_{config['region']}.pid"
        write_pid(pid_file)
        logging.info(f"Starting Arch server in live mode for region {config['region']}... PID written to {pid_file}")
        manager = ArchManager(config)
        manager.start()

    elif args.command == 'start_client':
        config = load_config(args.config_file)
        if 'region' not in config:
            sys.exit("Config must include 'region' (e.g., amer, apac).")
        if 'client_name' not in config:
            sys.exit("Config must include 'client_name' (e.g., myclient1).")
        config['mode'] = args.mode

        # Prepare parameters for logging
        run_timestamp = None
        mode_str = None
        if args.mode == 'replay':
            run_timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            mode_str = "parallel" if args.parallel else "sequential"

        # Determine client's folder path for logs and outputs
        client_script_abs = os.path.abspath(args.client_script)
        client_dir = os.path.dirname(client_script_abs)
        config_name = os.path.splitext(os.path.basename(args.config_file))[0]  # e.g., 'client_amer'
        log_dir = setup_logging(config, args.mode, is_server=False, client_dir=client_dir, config_name=config_name, run_timestamp=run_timestamp, mode_str=mode_str)  # Client-specific logging

        # Dynamically import client script and get the client class
        spec = importlib.util.spec_from_file_location("client_module", client_script_abs)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        client_class = next((cls for cls in vars(module).values() if isinstance(cls, type) and issubclass(cls, ArchClient) and cls != ArchClient), None)
        if not client_class:
            sys.exit(f"No ArchClient subclass found in {args.client_script}")

        client = client_class(config, config['client_name'])  # Use client_name from config
        # Write PID under client's folder (e.g., <client_dir>/pids/<client_name>.pid)
        pid_dir = os.path.join(client_dir, 'pids')
        pid_file = f"{pid_dir}/{config['client_name']}.pid"
        write_pid(pid_file)

        if args.mode == 'live':
            logging.info(f"Starting client {config['client_name']} in live mode for region {config['region']}... PID written to {pid_file}")
            client.listen()
            while True:
                time.sleep(1)

        elif args.mode == 'replay':
            logging.info(f"Starting client {config['client_name']} in replay mode for region {config['region']} (processing directly)... PID written to {pid_file}")
            # Clamp num_processes (min 1, max 20)
            num_processes = max(1, min(args.num_processes, 20))
            # Convert timeout from minutes to seconds
            timeout_seconds = args.timeout * 60
            # Call the helper function for replay logic
            replay_helper.run_replay(config, args.parallel, client_class, client_script_abs, client_dir, config_name, log_dir, run_timestamp, num_processes, timeout_seconds)

            os.remove(pid_file)  # Clean up after completion (replay finishes)

    elif args.command == 'stop_server':
        pid_file = f"pids/arch_server_{args.region}.pid"
        stop_process(pid_file)

    elif args.command == 'stop_client':
        config = load_config(args.config_file)
        if 'client_name' not in config:
            sys.exit("Config must include 'client_name' (e.g., myclient1).")
        # Derive client_dir from client_script
        client_script_abs = os.path.abspath(args.client_script)
        client_dir = os.path.dirname(client_script_abs)
        pid_dir = os.path.join(client_dir, 'pids')
        pid_file = f"{pid_dir}/{config['client_name']}.pid"
        stop_process(pid_file)

if __name__ == "__main__":
    main()
