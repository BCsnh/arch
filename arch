#!/usr/bin/env python

import argparse
import yaml
import sys
import logging
import importlib
from core.arch_manager import ArchManager
from core.arch_client import ArchSignalClient
import time
import os
import signal
from datetime import datetime
import pandas as pd

def load_config(file_path):
    with open(file_path, 'r') as f:
        return yaml.safe_load(f)

def setup_logging(config, mode, is_server=False, client_dir=None, config_name=None):
    current_date = datetime.now().strftime('%Y%m%d')

    if is_server:
        # Server logs: server_live_<configname>_<date>.log
        log_dir = config.get('log_dir', './logs/server')
        os.makedirs(log_dir, exist_ok=True)
        log_file = f"{log_dir}/server_live_{config_name}_{current_date}.log"
    else:
        # Client logs
        client_name = config['client_name']  # Use client_name from config
        log_dir = os.path.join(client_dir, config.get('log_dir', 'logs'))  # Relative to client folder
        os.makedirs(log_dir, exist_ok=True)
        if mode == 'live':
            # client_<myclientname>_live_<configname>_<date>.log
            log_file = f"{log_dir}/client_{client_name}_live_{config_name}_{current_date}.log"
        else:  # replay
            # client_<myclientname>_replay_<configname>_<startdate>_<enddate>.log
            start_date = pd.to_datetime(config['historical_range']['start']).strftime('%Y%m%d')
            end_date = pd.to_datetime(config['historical_range']['end']).strftime('%Y%m%d')
            log_file = f"{log_dir}/client_{client_name}_replay_{config_name}_{start_date}_{end_date}.log"

    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(processName)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file),
            logging.StreamHandler()
        ]
    )

def write_pid(pid_file):
    os.makedirs(os.path.dirname(pid_file), exist_ok=True)  # Create dir if needed (e.g., for client pids)
    with open(pid_file, 'w') as f:
        f.write(str(os.getpid()))

def stop_process(pid_file):
    if not os.path.exists(pid_file):
        print(f"No process found for {pid_file}")
        sys.exit(1)
    with open(pid_file, 'r') as f:
        pid = int(f.read().strip())
    try:
        os.kill(pid, signal.SIGTERM)
        print(f"Sent termination signal to PID {pid}")
        os.remove(pid_file)  # Clean up PID file
    except ProcessLookupError:
        print(f"Process {pid} not found")
        os.remove(pid_file)
    except Exception as e:
        print(f"Error stopping process: {e}")

def main():
    parser = argparse.ArgumentParser(description="Arch Framework CLI")
    subparsers = parser.add_subparsers(dest='command', required=True)

    # start_server subcommand
    server_parser = subparsers.add_parser('start_server')
    server_parser.add_argument('mode', choices=['live'], help="Mode (only live for server)")
    server_parser.add_argument('config_file', help="Server config YAML file")

    # start_client subcommand
    client_parser = subparsers.add_parser('start_client')
    client_parser.add_argument('mode', choices=['live', 'replay'], help="Mode (live or replay)")
    client_parser.add_argument('client_script', help="Client script file (e.g., clients/client1.py)")
    client_parser.add_argument('config_file', help="Client config YAML file")

    # stop_server subcommand
    stop_server_parser = subparsers.add_parser('stop_server')
    stop_server_parser.add_argument('region', help="Region of the server to stop (e.g., amer)")

    # stop_client subcommand (takes client_script and config_file)
    stop_client_parser = subparsers.add_parser('stop_client')
    stop_client_parser.add_argument('client_script', help="Client script file to locate PID folder")
    stop_client_parser.add_argument('config_file', help="Client config YAML file to load client_name")

    args = parser.parse_args()

    if args.command == 'start_server':
        if args.mode != 'live':
            sys.exit("Server only supports live mode.")
        config = load_config(args.config_file)
        if 'region' not in config:
            sys.exit("Config must include 'region' (e.g., amer, apac).")
        config['mode'] = 'live'
        config_name = os.path.splitext(os.path.basename(args.config_file))[0]  # e.g., 'server_amer'
        setup_logging(config, config['mode'], is_server=True, config_name=config_name)  # Server-specific logging
        pid_file = f"pids/arch_server_{config['region']}.pid"
        write_pid(pid_file)
        logging.info(f"Starting Arch server in live mode for region {config['region']}... PID written to {pid_file}")
        manager = ArchManager(config)
        manager.start()

    elif args.command == 'start_client':
        config = load_config(args.config_file)
        if 'region' not in config:
            sys.exit("Config must include 'region' (e.g., amer, apac).")
        if 'client_name' not in config:
            sys.exit("Config must include 'client_name' (e.g., myclient1).")
        config['mode'] = args.mode

        # Determine client's folder path for logs and outputs
        client_script_abs = os.path.abspath(args.client_script)
        client_dir = os.path.dirname(client_script_abs)
        config_name = os.path.splitext(os.path.basename(args.config_file))[0]  # e.g., 'client_amer'
        setup_logging(config, args.mode, is_server=False, client_dir=client_dir, config_name=config_name)  # Client-specific logging

        # Dynamically import client script and get the client class
        spec = importlib.util.spec_from_file_location("client_module", client_script_abs)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        client_class = next((cls for cls in vars(module).values() if isinstance(cls, type) and issubclass(cls, ArchSignalClient) and cls != ArchSignalClient), None)
        if not client_class:
            sys.exit(f"No ArchSignalClient subclass found in {args.client_script}")

        client = client_class(config, config['client_name'])  # Use client_name from config
        # Write PID under client's folder (e.g., <client_dir>/pids/<client_name>.pid)
        pid_dir = os.path.join(client_dir, 'pids')
        pid_file = f"{pid_dir}/{config['client_name']}.pid"
        write_pid(pid_file)

        if args.mode == 'live':
            logging.info(f"Starting client {config['client_name']} in live mode for region {config['region']}... PID written to {pid_file}")
            client.listen()
            while True:
                time.sleep(1)

        elif args.mode == 'replay':
            logging.info(f"Starting client {config['client_name']} in replay mode for region {config['region']} (processing directly)... PID written to {pid_file}")
            from core.arch_data_loader import ArchDataLoader
            from core.arch_calendar import Calendar  # Import for calendar scheduling
            
            loader = ArchDataLoader(config)
            
            # Use calendar if enabled in config
            if 'calendar' in config.keys():
                calendar = Calendar(config)
                valid_dates = calendar.get_valid_dates(config['historical_range']['start'], config['historical_range']['end'])
                periods = [(date, date + pd.Timedelta(days=1)) for date in valid_dates]  # Example: daily periods on valid dates
            else:
                periods = loader.get_periods()  # Fallback to original sequential periods

            def process_period(period_tuple):
                period_start, period_end = period_tuple
                data = loader.load_data(period_start, period_end)
                client.process_period(period_start, data)

            # Set replay output dir relative to client's folder path
            config['output_dir'] = os.path.join(client_dir, config.get('output_dir', 'outputs'))  # Relative to client

            if config.get('replay_parallel', False):
                from multiprocessing import Pool
                import multiprocessing_logging
                multiprocessing_logging.install_mp_handler()
                with Pool(processes=4) as pool:
                    pool.map(process_period, periods)
            else:
                for period in periods:
                    process_period(period)

            logging.info(f"Replay completed for client {config['client_name']}")
            os.remove(pid_file)  # Clean up after completion (replay finishes)

    elif args.command == 'stop_server':
        pid_file = f"pids/arch_server_{args.region}.pid"
        stop_process(pid_file)

    elif args.command == 'stop_client':
        config = load_config(args.config_file)
        if 'client_name' not in config:
            sys.exit("Config must include 'client_name' (e.g., myclient1).")
        # Derive client_dir from client_script
        client_script_abs = os.path.abspath(args.client_script)
        client_dir = os.path.dirname(client_script_abs)
        pid_dir = os.path.join(client_dir, 'pids')
        pid_file = f"{pid_dir}/{config['client_name']}.pid"
        stop_process(pid_file)

if __name__ == "__main__":
    main()
