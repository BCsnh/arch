#!/usr/bin/env python

import argparse
import yaml
import sys
import logging
import importlib
from core.arch_manager import ArchManager
from core.arch_client import ArchSignalClient
import time
import os
import signal

def load_config(file_path):
    with open(file_path, 'r') as f:
        return yaml.safe_load(f)

def setup_logging(config):
    log_dir = config.get('log_dir', './logs')
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(processName)s - %(message)s',
        handlers=[
            logging.FileHandler(f"{log_dir}/arch_{config['region']}.log"),
            logging.StreamHandler()
        ]
    )

def write_pid(pid_file):
    os.makedirs('pids', exist_ok=True)
    with open(pid_file, 'w') as f:
        f.write(str(os.getpid()))

def stop_process(pid_file):
    if not os.path.exists(pid_file):
        print(f"No process found for {pid_file}")
        sys.exit(1)
    with open(pid_file, 'r') as f:
        pid = int(f.read().strip())
    try:
        os.kill(pid, signal.SIGTERM)
        print(f"Sent termination signal to PID {pid}")
        os.remove(pid_file)  # Clean up PID file
    except ProcessLookupError:
        print(f"Process {pid} not found")
        os.remove(pid_file)
    except Exception as e:
        print(f"Error stopping process: {e}")

def main():
    parser = argparse.ArgumentParser(description="Arch Framework CLI")
    subparsers = parser.add_subparsers(dest='command', required=True)

    # start_server subcommand
    server_parser = subparsers.add_parser('start_server')
    server_parser.add_argument('mode', choices=['live'], help="Mode (only live for server)")
    server_parser.add_argument('config_file', help="Server config YAML file")

    # start_client subcommand
    client_parser = subparsers.add_parser('start_client')
    client_parser.add_argument('mode', choices=['live', 'replay'], help="Mode (live or replay)")
    client_parser.add_argument('client_script', help="Client script file (e.g., clients/client1.py)")
    client_parser.add_argument('config_file', help="Client config YAML file")

    # stop_server subcommand
    stop_server_parser = subparsers.add_parser('stop_server')
    stop_server_parser.add_argument('region', help="Region of the server to stop (e.g., amer)")

    # stop_client subcommand
    stop_client_parser = subparsers.add_parser('stop_client')
    stop_client_parser.add_argument('client_id', help="Client ID to stop (e.g., Client1_amer)")

    args = parser.parse_args()

    if args.command == 'start_server':
        if args.mode != 'live':
            sys.exit("Server only supports live mode.")
        config = load_config(args.config_file)
        if 'region' not in config:
            sys.exit("Config must include 'region' (e.g., amer, apac).")
        config['mode'] = 'live'
        setup_logging(config)
        pid_file = f"pids/arch_server_{config['region']}.pid"
        write_pid(pid_file)
        logging.info(f"Starting Arch server in live mode for region {config['region']}... PID written to {pid_file}")
        manager = ArchManager(config)
        manager.start()

    elif args.command == 'start_client':
        config = load_config(args.config_file)
        if 'region' not in config:
            sys.exit("Config must include 'region' (e.g., amer, apac).")
        config['mode'] = args.mode
        setup_logging(config)

        # Dynamically import client script and get the client class
        spec = importlib.util.spec_from_file_location("client_module", args.client_script)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        client_class = next((cls for cls in vars(module).values() if isinstance(cls, type) and issubclass(cls, ArchSignalClient) and cls != ArchSignalClient), None)
        if not client_class:
            sys.exit(f"No ArchSignalClient subclass found in {args.client_script}")

        client_id = f"{client_class.__name__}_{config['region']}"
        client = client_class(config, client_id)
        pid_file = f"pids/{client_id}.pid"
        write_pid(pid_file)

        if args.mode == 'live':
            logging.info(f"Starting client {client_id} in live mode for region {config['region']}... PID written to {pid_file}")
            client.listen()
            while True:
                time.sleep(1)

        elif args.mode == 'replay':
            logging.info(f"Starting client {client_id} in replay mode for region {config['region']} (processing directly)... PID written to {pid_file}")
            from core.arch_data_loader import ArchDataLoader
            loader = ArchDataLoader(config)
            periods = loader.get_periods()

            def process_period(period_tuple):
                period_start, period_end = period_tuple
                data = loader.load_data(period_start, period_end)
                client.process_period(period_start, data)

            if config.get('replay_parallel', False):
                from multiprocessing import Pool
                import multiprocessing_logging
                multiprocessing_logging.install_mp_handler()
                with Pool(processes=4) as pool:
                    pool.map(process_period, periods)
            else:
                for period in periods:
                    process_period(period)

            logging.info(f"Replay completed for client {client_id}")
            os.remove(pid_file)  # Clean up after completion (replay finishes)

    elif args.command == 'stop_server':
        pid_file = f"pids/arch_server_{args.region}.pid"
        stop_process(pid_file)

    elif args.command == 'stop_client':
        pid_file = f"pids/{args.client_id}.pid"
        stop_process(pid_file)

if __name__ == "__main__":
    main()
